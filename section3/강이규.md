## 회원 관리 구현 - 서블릿, JSP, MVC 패턴
---
## 애플리케이션 요구사항
#### 회원 정보
- 이름
- 나이
#### 기능
- 회원 저장
- 회원 목록 조회

---
## 도메인, 저장소 구현

#### Member
- id
- username
- age
- Getter/Setter
- NoArgs/AllArgs 생성자

#### MemberRepository
- save
- findById
- findAll
- clear -> 테스트코드용
- ```싱글톤 패턴 적용```
  - 자기 인스턴스를 static final 변수로 선언하고,
  - 생성자를 private으로 막고,
  - public인 getInstance() 메소드로만 접근하도록 제한

-> 실제 사용 시, 동시성 문제 고려

---
## 기능 구현
- ```MemberForm``` : 회원정보 입력 페이지
- ```MemberSave``` : 회원 저장
- ```MemberList``` : 회원 목록 조회
---

### 서블릿

```java
@WebServlet(name = "memberFormServlet", urlPatterns = "/servlet/members/new-form")
public class MemberFormServlet extends HttpServlet {

    private MemberRepository memberRepository = MemberRepository.getInstance(); // 싱글톤

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 메인 로직
    }
```

이처럼 **HttpServlet을 상속**하고, **service()를 오버라이딩**해서 사용

#### <장점>
- **반복 작업 제거** : 요청~응답 과정 중, 메인 로직을 제외한 부분을 대신 처리
- **동적 리소스 반환 가능** : ```response.setAttribute()``` 또는 ```response.getWrtier().write()``` 를 통해 데이터, html 등 반환
#### <한계점>
- **html 생성 번거로움**

  아래는 회원 목록조회 코드 일부이다.
  ```java
    @Override
    protected void service(HttpServletRequest requset, HttpServletResponse response) throws ServletException, IOException {
        // 메인 로직
        List<Member> members = memberRepository.findAll();

        // 렌더링 코드
        response.setContentType("text/html");
        response.setCharacterEncoding("utf-8");

        PrintWriter w = response.getWriter();
        w.write("<html>");
        w.write("<head>");
        w.write(" <meta charset=\"UTF-8\">");
        w.write(" <title>Title</title>");
        ...
    }
  ```
- **관심사 분리 X** : 각 서블릿에 메인 로직 + 렌더링 코드가 같이 있다.
---
### JSP
- 클라이언트는 jsp 파일을 **URI로 직접 요청**
  - ```localhost:8080/jsp/members/new-form.jsp```
- jsp 파일은 메인 로직 + view 로직 모두 포함
- 서블릿과 달리, view 관련 파일에서 자바 코드 사용

아래는 회원 목록조회 jsp파일 일부이다.
```jsp
<%@ page import="java.util.List" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%
  MemberRepository memberRepository = MemberRepository.getInstance();
  List<Member> members = memberRepository.findAll();

%>
<html>
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<a href="/index.html">메인</a>
<table>
  <%-- html 내부에도 삽입 가능 --%>
  <%
    for (Member member : members) {
      out.write(" <tr>"); // out도 예약어
      out.write(" <td>" + member.getId() + "</td>");
      out.write(" <td>" + member.getUsername() + "</td>");
      out.write(" <td>" + member.getAge() + "</td>");
      out.write(" </tr>");
    }
  %>
  </tbody>
```

#### <장점>
- **코드 작성 단순화** : 서블릿에서 html 작성보다 조금 더 쉽다.
#### <한계점>
- **관심사 분리 X**
  - 유지보수 어려움 : 변경 주기가 다를 것이므로
  - 변경 주기가 다른 관심사들은, 분리하는 것이 좋다.
- **정보의 노출** : jsp 파일에, repository 등 많은 정보가 노출됨

---
### MVC 패턴(서블릿, JSP)
![image](https://github.com/EhighG/23-5-Spring/assets/71206505/dbc39012-e1f8-412d-980d-3c48a28fd986)
- **MVC 패턴** : 애플리케이션 개발을 Model, View, Controller의 3가지 부분으로 나눈 디자인 패턴
- Controller : **서블릿**
- View : **JSP**
- Model : 서블릿의 **HttpRequest**
를 사용했다.

서블릿(Controller)은,
1. 비즈니스 로직 실행 후,
2. request(Model)에 데이터를 담고,
3. ```dispatcher.forward(request, response)``` 를 통해 jsp 파일(View) 호출
> **forward()** : 서버 내부에서 요청이 한 번 더 발생. redirect와는 다르며, 클라이언트에 노출되지 않는다.

> jsp 파일의 경로는 WEB-INF 하위에 두어, **클라이언트의 직접 호출을 방지** (WAS가 맞춰서 처리해준다.)
<br>

#### <장점>
- **관심사의 분리** : 비즈니스 로직은 Controller(+a)에, 렌더링 로직은 View에
  - jsp파일에 repository 등 **정보 노출 X**
- **렌더링 로직의 단순화** : 아래와 같이, jsp에서 비교적 간편하게 데이터 사용 가능
  ```jsp
  <tbody>
  <c:forEach var="item" items="${members}">
    <tr>
      <td>${item.id}</td>
      <td>${item.username}</td>
      <td>${item.age}</td>
    </tr>
  </c:forEach>
  </tbody>
  ```
#### <한계점>
- **request, response 필요성 감소** : 특히 response의 역할은 jsp로 대체되어, 거의 사용 X
- **테스트코드 작성 어려움** : HttpServletRequest/Response 사용 시
- **중복 코드 존재** : viewPath 선언 ~ forward() 부분, viewPath의 prefix, suffix

--> Controller 앞 단에, **FrontController를 두어 공통 로직을 처리**하는 것이 낫다.

(=**Front Controller 패턴** / Spring MVC를 포함한 MVC 프레임워크들도, 이를 구현한 것)
  
